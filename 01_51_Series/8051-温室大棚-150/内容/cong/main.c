/*
项目名称：温室哨兵 - 中文修复编译版
适配芯片：STC89C52RC / AT89C52
晶振频率：11.0592 MHz
编译环境：Keil C51 (已修复C89变量声明问题)
*/

#include <reg52.h>
#include <intrins.h>
#include <string.h>

// 定义nop为_nop_()，解决 warning C206
#define nop() _nop_()

//========================================================================
//                           1. 角色配置
//========================================================================
// 0x01:主机, 0x02:从机1, 0x03:从机2
#define CURRENT_ID    0x02    // <--- 烧录前务必修改这里 (0x01, 0x02, 0x03)

#if (CURRENT_ID == 0x01)
    #define IS_MASTER 1
#else
    #define IS_MASTER 0
#endif

#define MASTER_ID   0x01
#define SLAVE_1_ID  0x02
#define SLAVE_2_ID  0x03

//========================================================================
//                           2. 硬件引脚
//========================================================================
sbit DS18B20_PIN = P1^5;
sbit DS1302_RST  = P1^4;
sbit DS1302_IO   = P1^3;
sbit DS1302_SCLK = P1^2;
sbit OLED_SCL    = P2^0;
sbit OLED_SDA    = P2^1;
sbit BUZZER      = P1^7;

// 按键定义
sbit KEY_COMMON = P3^2; // 主机:停止报警 / 从机:切换植物
sbit KEY_M_VIEW = P1^6; // 主机:切换视图
sbit KEY_M_ADDH = P3^3; // 主机:时+
sbit KEY_M_ADDM = P3^4; // 主机:分+

// LED 接在 P2.2 - P2.7 (逻辑：1亮 0灭)

//========================================================================
//                           3. 全局变量与常量
//========================================================================
typedef unsigned char u8;
typedef unsigned int  u16;
typedef unsigned long u32;

// 报警状态
#define ALARM_NONE 0
#define ALARM_B    1
#define ALARM_C    2
#define ALARM_D    3

// 通信指令
#define CMD_REPORT 0xA0
#define CMD_ALARM  0xB0

// 系统滴答
volatile u32 g_SysTick = 0;

// 全局状态
u8 g_Temp = 0;
u8 g_Time[7];
u8 g_SysAlarmState = ALARM_NONE;
bit g_ManualMute = 0; // 手动静音标志

// 串口
u8 g_RxBuffer[10];
u8 g_RxCnt = 0;
bit g_MsgReceived = 0;

// 按键标志
bit Key_Common_Press = 0;
bit Key_View_Press = 0;
bit Key_AddH_Press = 0;
bit Key_AddM_Press = 0;

// 植物库 (只存温度阈值，名字通过索引查字库)
typedef struct { 
    u8 min_temp; 
    u8 max_temp; 
} Plant;

code Plant PlantDB[10] = {
    {20, 28}, // 0: 玫瑰
    {15, 25}, // 1: 郁金香
    {18, 30}, // 2: 百合
    {10, 35}, // 3: 雏菊
    {15, 25}, // 4: 牡丹
    {20, 30}, // 5: 番茄
    {10, 25}, // 6: 土豆
    {25, 35}, // 7: 辣椒
    {5,  30}, // 8: 洋葱
    {25, 40}  // 9: 甜瓜
};

#if IS_MASTER
    struct SlaveInfo { u8 temp; u8 plant_id; u8 online_cnt; } S1_Data, S2_Data;
    u8 g_DisplayMode = 0; // 0:概览, 1:看从1详情, 2:看从2详情
#else
    u8 g_CurrentPlantIdx = 0;
#endif

// 音乐频率表 (Hz)
code u16 FREQ_TAB[] = { 0, 262, 294, 330, 349, 392, 440, 494, 523, 1000 };
code u8 Song_B[] = { 1,4, 2,4, 3,4, 0,0 }; // 报警B旋律
code u8 Song_C[] = { 3,4, 2,4, 1,4, 0,0 }; // 报警C旋律
code u8 Song_D[] = { 9,2, 0,2, 9,2, 0,0 }; // 报警D旋律

//========================================================================
//                           4. 汉字库 (16x16)
//========================================================================
// 索引对照表:
// 0:温 1:室 2:哨 3:兵 4:主 5:从 6:机 7:号 8:植 9:物 10:度 11:离 12:线 
// 13:玫 14:瑰 (玫瑰)
// 15:郁 16:金 17:香 (郁金香)
// 18:百 19:合 (百合)
// 20:雏 21:菊 (雏菊)
// 22:牡 23:丹 (牡丹)
// 24:番 25:茄 (番茄)
// 26:土 27:豆 (土豆)
// 28:辣 29:椒 (辣椒)
// 30:洋 31:葱 (洋葱)
// 32:甜 33:瓜 (甜瓜)

const u8 code HZ_16x16[] = {
    // 0: 温
    0x10,0x60,0x02,0x8C,0x00,0x00,0xFE,0x92,0x92,0x92,0x92,0x92,0xFE,0x00,0x00,0x00,
    0x04,0x04,0x7E,0x01,0x40,0x7E,0x42,0x42,0x7E,0x42,0x7E,0x42,0x42,0x7E,0x40,0x00,
    // 1: 室
    0x10,0x0C,0x24,0x24,0xA4,0x64,0x25,0x26,0x24,0x24,0xA4,0x24,0x24,0x14,0x0C,0x00,
    0x40,0x40,0x48,0x49,0x49,0x49,0x49,0x7F,0x49,0x49,0x49,0x4B,0x48,0x40,0x40,0x00,
    // 2: 哨
    0x00,0xFC,0x04,0x04,0xFC,0x00,0x00,0xE2,0x2C,0x20,0x3F,0x20,0x28,0xE6,0x00,0x00,
    0x00,0x0F,0x04,0x04,0x0F,0x00,0x00,0xFF,0x09,0x09,0x09,0x49,0x89,0x7F,0x00,0x00,
    // 3: 兵
    0x00,0x00,0x00,0xFC,0x24,0x24,0x24,0x24,0xE2,0x22,0x23,0x22,0x20,0x00,0x00,0x00,
    0x04,0x84,0x44,0x27,0x14,0x04,0x04,0x04,0x07,0x14,0x24,0x44,0x84,0x04,0x04,0x00,
    // 4: 主
    0x00,0x08,0x08,0x08,0x08,0x08,0x09,0xFA,0x08,0x08,0x08,0x08,0x08,0x08,0x00,0x00,
    0x40,0x40,0x41,0x41,0x41,0x41,0x41,0x7F,0x41,0x41,0x41,0x41,0x41,0x40,0x40,0x00,
    // 5: 从
    0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,
    0x80,0x40,0x30,0x0E,0x01,0x82,0x4C,0x20,0x18,0x07,0x00,0x07,0x18,0x60,0x80,0x00,
    // 6: 机
    0x10,0x10,0xD0,0xFF,0x90,0x10,0x00,0xFE,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,
    0x04,0x03,0x00,0xFF,0x00,0x83,0x60,0x1F,0x00,0x00,0x00,0x3F,0x40,0x40,0x78,0x00,
   // 号 (索引: 7)
0x80,0x80,0x80,0xBE,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xA2,0xBE,0x80,0x80,0x80,0x00,
0x00,0x00,0x00,0x06,0x05,0x04,0x04,0x04,0x44,0x84,0x44,0x3C,0x00,0x00,0x00,0x00,
    // 8: 植
    0x10,0x10,0xD0,0xFF,0x90,0x10,0x04,0xE4,0xA4,0xA4,0xBF,0xA4,0xA4,0xE4,0x04,0x00,
    0x04,0x03,0x00,0xFF,0x00,0x43,0x40,0x7F,0x4A,0x4A,0x4A,0x4A,0x4A,0x7F,0x40,0x00,
    // 9: 物
    0x40,0x3C,0x10,0xFF,0x10,0x10,0x20,0x10,0x8F,0x78,0x08,0xF8,0x08,0xF8,0x00,0x00,
    0x02,0x06,0x02,0xFF,0x01,0x01,0x04,0x42,0x21,0x18,0x46,0x81,0x40,0x3F,0x00,0x00,
    // 10: 度
    0x00,0x00,0xFC,0x24,0x24,0x24,0xFC,0x25,0x26,0x24,0xFC,0x24,0x24,0x24,0x04,0x00,
    0x40,0x30,0x8F,0x80,0x84,0x4C,0x55,0x25,0x25,0x25,0x55,0x4C,0x80,0x80,0x80,0x00,
   // 离 (索引: 11)
0x04,0x04,0x04,0xF4,0x84,0xD4,0xA5,0xA6,0xA4,0xD4,0x84,0xF4,0x04,0x04,0x04,0x00,
0x00,0xFE,0x02,0x02,0x12,0x3A,0x16,0x13,0x12,0x1A,0x32,0x42,0x82,0x7E,0x00,0x00,

    // 线 (索引: 12)
0x20,0x30,0xAC,0x63,0x20,0x18,0x80,0x90,0x90,0xFF,0x90,0x49,0x4A,0x48,0x40,0x00,
0x22,0x67,0x22,0x12,0x12,0x12,0x40,0x40,0x20,0x13,0x0C,0x14,0x22,0x41,0xF8,0x00,

    // 13: 玫
    0x04,0x44,0x44,0xFC,0x44,0x44,0x44,0x20,0xD8,0x17,0x10,0x10,0xF0,0x10,0x10,0x00,
    0x10,0x30,0x10,0x1F,0x08,0x08,0x88,0x40,0x21,0x16,0x08,0x16,0x21,0x40,0x80,0x00,
    // 14: 瑰
    0x84,0x84,0xFC,0x84,0x84,0x00,0xFC,0x24,0x24,0xA6,0x7D,0x24,0x24,0xFC,0x00,0x00,
    0x10,0x30,0x1F,0x08,0x08,0x80,0x41,0x31,0x0D,0x03,0x7D,0x99,0x95,0x99,0xE0,0x00,
    // 15: 郁
    0x04,0x84,0xE4,0x3C,0x27,0x24,0x24,0xE4,0x00,0x00,0xFE,0x02,0x22,0xDA,0x06,0x00,
    0x01,0x00,0xFF,0x09,0x09,0x49,0x89,0x7F,0x00,0x00,0xFF,0x08,0x10,0x08,0x07,0x00,
    // 16: 金
    0x80,0x80,0x40,0x20,0x50,0x48,0x44,0xC3,0x44,0x48,0x50,0x20,0x40,0x80,0x80,0x00,
    0x40,0x40,0x42,0x4A,0x72,0x42,0x42,0x7F,0x42,0x42,0x62,0x5A,0x42,0x40,0x40,0x00,
    // 17: 香
    0x10,0x10,0x90,0x92,0x52,0x32,0x12,0xFE,0x12,0x31,0x51,0x91,0x90,0x10,0x10,0x00,
    0x01,0x01,0x00,0xFF,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0xFF,0x00,0x01,0x01,0x00,
    // 18: 百
    0x02,0x02,0xE2,0x22,0x22,0x32,0x2A,0x26,0x22,0x22,0x22,0x22,0xE2,0x02,0x02,0x00,
    0x00,0x00,0xFF,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0xFF,0x00,0x00,0x00,
    // 19: 合
    0x40,0x40,0x20,0x20,0x50,0x48,0x44,0x43,0x44,0x48,0x50,0x20,0x20,0x40,0x40,0x00,
    0x00,0x00,0x00,0xFE,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0xFE,0x00,0x00,0x00,0x00,
    // 20: 雏
    0x50,0x48,0x47,0x44,0x64,0x54,0xEC,0x10,0xFC,0x4B,0x48,0xF9,0x4A,0x48,0x08,0x00,
    0x20,0x22,0x22,0x22,0x22,0x22,0x7F,0x00,0xFF,0x22,0x22,0x3F,0x22,0x22,0x20,0x00,
    // 21: 菊
    0x04,0x84,0x44,0xB4,0x24,0x2F,0xE4,0x24,0x24,0xAF,0x24,0x24,0x24,0xE4,0x04,0x00,
    0x01,0x44,0x44,0x24,0x15,0x0C,0xFF,0x0C,0x15,0x24,0x04,0x44,0x80,0x7F,0x00,0x00,
    // 22: 牡
    0x40,0x3C,0x10,0x10,0xFF,0x10,0x10,0x40,0x40,0x40,0xFF,0x40,0x40,0x40,0x00,0x00,
    0x02,0x06,0x02,0x02,0xFF,0x01,0x41,0x40,0x40,0x40,0x7F,0x40,0x40,0x40,0x40,0x00,
    // 23: 丹
    0x00,0x00,0x00,0xFE,0x02,0x02,0x12,0x62,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,
    0x81,0x41,0x31,0x0F,0x01,0x01,0x01,0x01,0x01,0x41,0x81,0x7F,0x01,0x01,0x01,0x00,
    // 24: 番
    0x20,0x20,0x22,0xA6,0x6A,0x22,0x22,0x7E,0x21,0x21,0x69,0xA5,0x21,0x20,0x20,0x00,
    0x02,0x02,0x01,0xFF,0x49,0x49,0x49,0x7F,0x49,0x49,0x49,0xFF,0x01,0x02,0x02,0x00,
    // 25: 茄
    0x04,0x84,0x84,0xE4,0x8F,0x84,0x84,0x04,0x04,0xC4,0x4F,0x44,0x44,0xC4,0x04,0x00,
    0x80,0x40,0x30,0x0F,0x40,0x80,0x7F,0x00,0x00,0xFF,0x40,0x40,0x40,0xFF,0x00,0x00,
    // 26: 土
    0x00,0x00,0x40,0x40,0x40,0x40,0x40,0xFF,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x00,
    0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x7F,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,
    // 27: 豆
    0x00,0x02,0x02,0xF2,0x12,0x12,0x12,0x12,0x12,0x12,0x12,0xF2,0x02,0x02,0x00,0x00,
    0x40,0x40,0x40,0x4B,0x52,0x62,0x42,0x42,0x42,0x62,0x52,0x4B,0x40,0x40,0x40,0x00,
    // 28: 辣
    0x88,0xA8,0xC9,0x8E,0xC8,0xA8,0x00,0xE4,0x24,0x24,0xFF,0x24,0x24,0xE4,0x00,0x00,
    0x84,0x44,0x34,0x0F,0x04,0x04,0x20,0x11,0x09,0x05,0xFF,0x05,0x09,0x11,0x20,0x00,
    // 29: 椒
    0x10,0x90,0xFF,0x90,0x10,0x40,0x40,0x7F,0x44,0x44,0x00,0xFC,0x04,0xFC,0x00,0x00,
    0x06,0x01,0xFF,0x00,0x11,0x4C,0x80,0x7F,0x04,0x18,0x80,0x63,0x1C,0x63,0x80,0x00,
    // 30: 洋
    0x10,0x60,0x02,0x8C,0x00,0x10,0x91,0x96,0x90,0xF0,0x90,0x94,0x93,0x10,0x00,0x00,
    0x04,0x04,0x7E,0x01,0x00,0x04,0x04,0x04,0x04,0xFF,0x04,0x04,0x04,0x04,0x04,0x00,
    // 31: 葱
    0x04,0x84,0x44,0x24,0x74,0xAF,0x64,0x24,0x24,0xEF,0x24,0x24,0xE4,0x04,0x04,0x00,
    0x80,0x60,0x04,0x02,0x61,0x88,0x85,0x92,0xA5,0x80,0x84,0xC8,0x07,0x20,0xC0,0x00,
    // 32: 甜
    0x20,0x24,0x24,0xFE,0x23,0x22,0x00,0x10,0xFF,0x10,0x10,0x10,0xFF,0x10,0x10,0x00,
    0x00,0x7F,0x21,0x21,0x21,0x7F,0x00,0x00,0xFF,0x42,0x42,0x42,0xFF,0x00,0x00,0x00,
    // 33: 瓜
    0x00,0x00,0x00,0xFC,0x04,0x04,0xFC,0x04,0x02,0x02,0xFE,0x03,0x02,0x00,0x00,0x00,
    0x80,0x60,0x18,0x07,0x00,0x00,0x7F,0x20,0x14,0x08,0x31,0x0E,0x30,0x40,0x80,0x00
};

// ASCII 8x16 极简字库 (数字和标点)
const u8 code F8X16[] = {
    // 0
    0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,
    // 1
    0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,
    // 2
    0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,
    // 3
    0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,
    // 4
    0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,
    // 5
    0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,
    // 6
    0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,
    // 7
    0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,
    // 8
    0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,
    // 9
    0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,
    // : (10)
    0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,
    // - (11)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
    // Space (12)
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

//========================================================================
//                           5. 基础驱动
//========================================================================
void Delay_OneWire(u16 us) { while(us--); }
void DelayMs(u16 ms) { u16 i, j; for(i=0; i<ms; i++) for(j=0; j<110; j++); }

void I2C_Start() { OLED_SDA=1; OLED_SCL=1; nop(); OLED_SDA=0; nop(); OLED_SCL=0; }
void I2C_Stop()  { OLED_SDA=0; OLED_SCL=1; nop(); OLED_SDA=1; }
void I2C_SendByte(u8 dat) { u8 i; for(i=0;i<8;i++) { OLED_SDA=dat&0x80;dat<<=1; OLED_SCL=1;nop();OLED_SCL=0;} OLED_SCL=1;nop();OLED_SCL=0;}
void OLED_WrCmd(u8 cmd) { I2C_Start(); I2C_SendByte(0x78); I2C_SendByte(0x00); I2C_SendByte(cmd); I2C_Stop(); }
void OLED_WrDat(u8 dat) { I2C_Start(); I2C_SendByte(0x78); I2C_SendByte(0x40); I2C_SendByte(dat); I2C_Stop(); }
void OLED_Init() { DelayMs(200); OLED_WrCmd(0xAE); OLED_WrCmd(0x8D); OLED_WrCmd(0x14); OLED_WrCmd(0xAF); }
void OLED_SetPos(u8 x, u8 y) { OLED_WrCmd(0xB0+y); OLED_WrCmd(((x&0xF0)>>4)|0x10); OLED_WrCmd(x&0x0F); }
void OLED_Clear() { u8 i,n; for(i=0;i<8;i++){OLED_WrCmd(0xb0+i);OLED_WrCmd(0x00);OLED_WrCmd(0x10);for(n=0;n<128;n++)OLED_WrDat(0);} }

// 显示 16x16 汉字 (N为数组索引)
void OLED_ShowCN(u8 x, u8 y, u8 N) {
    u8 i;
    if(x > 112) { x = 0; y += 2; }
    OLED_SetPos(x, y);
    for(i=0; i<16; i++) OLED_WrDat(HZ_16x16[N*32 + i]);
    OLED_SetPos(x, y+1);
    for(i=0; i<16; i++) OLED_WrDat(HZ_16x16[N*32 + i + 16]);
}

// 显示数字/符号 (ASCII)
void OLED_ShowChar(u8 x, u8 y, char chr) {
    u8 c = 0;
    u8 i;
    if(chr >= '0' && chr <= '9') c = chr - '0';
    else if(chr == ':') c = 10;
    else if(chr == '-') c = 11;
    else c = 12; // Space
    
    if(x > 120) { x = 0; y += 2; }
    OLED_SetPos(x, y);
    for(i=0; i<8; i++) OLED_WrDat(F8X16[c*16 + i]);
    OLED_SetPos(x, y+1);
    for(i=0; i<8; i++) OLED_WrDat(F8X16[c*16 + i + 8]);
}

void OLED_ShowNum(u8 x, u8 y, u16 num, u8 len) {
    u8 t,temp; 
    for(t=0;t<len;t++) { 
        if(len==2) temp=(num/(t==0?10:1))%10; 
        OLED_ShowChar(x+8*t, y, temp+'0'); 
    }
}

// 显示植物名称 (根据ID查找对应汉字)
void OLED_ShowPlantName(u8 x, u8 y, u8 id) {
    // 0:玫瑰(13,14), 1:郁金香(15,16,17), 2:百合(18,19), 3:雏菊(20,21)
    // 4:牡丹(22,23), 5:番茄(24,25), 6:土豆(26,27), 7:辣椒(28,29)
    // 8:洋葱(30,31), 9:甜瓜(32,33)
    if(id==0) { OLED_ShowCN(x,y,13); OLED_ShowCN(x+16,y,14); }
    else if(id==1) { OLED_ShowCN(x,y,15); OLED_ShowCN(x+16,y,16); OLED_ShowCN(x+32,y,17); }
    else if(id==2) { OLED_ShowCN(x,y,18); OLED_ShowCN(x+16,y,19); }
    else if(id==3) { OLED_ShowCN(x,y,20); OLED_ShowCN(x+16,y,21); }
    else if(id==4) { OLED_ShowCN(x,y,22); OLED_ShowCN(x+16,y,23); }
    else if(id==5) { OLED_ShowCN(x,y,24); OLED_ShowCN(x+16,y,25); }
    else if(id==6) { OLED_ShowCN(x,y,26); OLED_ShowCN(x+16,y,27); }
    else if(id==7) { OLED_ShowCN(x,y,28); OLED_ShowCN(x+16,y,29); }
    else if(id==8) { OLED_ShowCN(x,y,30); OLED_ShowCN(x+16,y,31); }
    else if(id==9) { OLED_ShowCN(x,y,32); OLED_ShowCN(x+16,y,33); }
}

// ... DS18B20 & DS1302 驱动 ...
void DS18B20_Rst() {
    bit ea=EA; EA=0;
    DS18B20_PIN=0; Delay_OneWire(60); DS18B20_PIN=1; Delay_OneWire(6); Delay_OneWire(20);
    EA=ea;
}
void DS18B20_Wr(u8 dat) {
    u8 i; bit ea=EA;
    for(i=0;i<8;i++) {
        EA=0; DS18B20_PIN=0; Delay_OneWire(1); DS18B20_PIN=dat&0x01; Delay_OneWire(6); DS18B20_PIN=1; dat>>=1; EA=ea;
    }
}
u8 DS18B20_Rd() {
    u8 i,dat=0; bit ea=EA;
    for(i=0;i<8;i++) {
        dat>>=1; EA=0; DS18B20_PIN=0; Delay_OneWire(1); DS18B20_PIN=1; nop();nop(); if(DS18B20_PIN) dat|=0x80; Delay_OneWire(6); EA=ea;
    }
    return dat;
}
u8 Get_Temp() {
    u8 l,h; DS18B20_Rst(); DS18B20_Wr(0xCC); DS18B20_Wr(0x44);
    DS18B20_Rst(); DS18B20_Wr(0xCC); DS18B20_Wr(0xBE);
    l=DS18B20_Rd(); h=DS18B20_Rd(); return (h<<4)|(l>>4);
}
void DS1302_Wr(u8 dat) { u8 i; for(i=0;i<8;i++) { DS1302_IO=dat&0x01; DS1302_SCLK=1; nop(); DS1302_SCLK=0; nop(); dat>>=1; } }
u8 DS1302_Rd() { u8 i,dat=0; for(i=0;i<8;i++) { dat>>=1; if(DS1302_IO) dat|=0x80; DS1302_SCLK=1; nop(); DS1302_SCLK=0; nop(); } return dat; }
u8 DS1302_RdReg(u8 cmd) { u8 dat; DS1302_RST=0; DS1302_SCLK=0; DS1302_RST=1; DS1302_Wr(cmd); dat=DS1302_Rd(); DS1302_RST=0; return dat; }
void Get_Time() { u8 t; t=DS1302_RdReg(0x85); g_Time[2]=(t/16)*10+(t%16); t=DS1302_RdReg(0x83); g_Time[1]=(t/16)*10+(t%16); t=DS1302_RdReg(0x81); g_Time[0]=(t/16)*10+(t%16); }

//========================================================================
//                           6. 核心驱动 (定时器/中断)
//========================================================================
void Buzzer_Set(u16 freq) {
    u16 reload;
    if(freq == 0) { TR2 = 0; BUZZER = 1; return; }
    reload = 65536 - (460800 / freq);
    RCAP2H = reload >> 8; RCAP2L = reload & 0xFF;
    TH2 = RCAP2H; TL2 = RCAP2L;
    TR2 = 1;
}

void Timer2_ISR() interrupt 5 { TF2 = 0; BUZZER = ~BUZZER; }

void Timer0_Init() {
    TMOD &= 0xF0; TMOD |= 0x01;
    TH0 = (65536 - 922) / 256; TL0 = (65536 - 922) % 256;
    ET0 = 1; TR0 = 1; EA = 1;
}

u8 Key_Read(bit pin_state, u8 *cnt) {
    if (pin_state == 0) { if (*cnt < 20) (*cnt)++; if (*cnt == 5) return 1; } 
    else { *cnt = 0; }
    return 0;
}

void Timer0_ISR() interrupt 1 {
    static u8 cnt_common=0, cnt_view=0, cnt_addh=0, cnt_addm=0;
    TH0 = (65536 - 922) / 256; TL0 = (65536 - 922) % 256;
    g_SysTick++;
    if (g_SysTick % 20 == 0) {
        if (Key_Read(KEY_COMMON, &cnt_common)) Key_Common_Press = 1;
        #if IS_MASTER
            if (Key_Read(KEY_M_VIEW, &cnt_view)) Key_View_Press = 1;
            if (Key_Read(KEY_M_ADDH, &cnt_addh)) Key_AddH_Press = 1;
            if (Key_Read(KEY_M_ADDM, &cnt_addm)) Key_AddM_Press = 1;
        #endif
    }
}

//========================================================================
//                           7. 业务逻辑 (1=亮, 0=灭)
//========================================================================
void Update_LEDs() {
    static u8 step = 0;
    static bit flash = 0;

    // 1. 无报警：全部常亮 (输出1)
    if (g_SysAlarmState == ALARM_NONE) { 
        P2 = P2 | 0xFC; 
        return; 
    }

    // 2. 报警B (从机1异常)：主机和从机1流水灯
    if (g_SysAlarmState == ALARM_B) {
        if (CURRENT_ID == MASTER_ID || CURRENT_ID == SLAVE_1_ID) {
            P2 = (P2 & 0x03) | (0x04 << step); // 移位高电平
            step++; if(step > 5) step = 0;
        } else {
            P2 = P2 | 0xFC; // 正常机常亮
        }
    } 
    // 3. 报警C (从机2异常)：主机和从机2流水灯
    else if (g_SysAlarmState == ALARM_C) {
        if (CURRENT_ID == MASTER_ID || CURRENT_ID == SLAVE_2_ID) {
            P2 = (P2 & 0x03) | (0x80 >> step); // 移位高电平
            step++; if(step > 5) step = 0;
        } else {
            P2 = P2 | 0xFC;
        }
    }
    // 4. 报警D (都异常)：所有设备闪烁
    else { 
        flash = !flash; 
        // flash=1时输出0(灭), flash=0时输出1(亮)
        P2 = (P2 & 0x03) | (flash ? 0x00 : 0xFC); 
    }
}

void Update_Music() {
    static u8 note_idx = 0;
    static u32 note_start_time = 0;
    u8 *song;
    u8 note, beats;
    u16 duration;

    if (g_SysAlarmState == ALARM_NONE) { Buzzer_Set(0); return; }

    if (g_SysAlarmState == ALARM_B) song = Song_B;
    else if (g_SysAlarmState == ALARM_C) song = Song_C;
    else song = Song_D;

    note = song[note_idx]; beats = song[note_idx+1];
    if (note == 0 && beats == 0) { note_idx = 0; return; }

    duration = beats * 50; 
    if (g_SysTick - note_start_time > duration) { 
        note_idx += 2; 
        note_start_time = g_SysTick; 
        if (song[note_idx] != 0) Buzzer_Set(FREQ_TAB[song[note_idx]]); else Buzzer_Set(0);
    }
}

//========================================================================
//                           8. 通信与主函数
//========================================================================
void UART_Init() { TMOD|=0x20; TH1=0xFD; TL1=0xFD; TR1=1; SCON=0x50; ES=1; EA=1; }
void UART_Send(u8 dat) { SBUF=dat; while(!TI); TI=0; }
void Send_Packet(u8 id, u8 cmd, u8 d1, u8 d2) {
    bit ea = EA; EA = 0;
    UART_Send(0xAA); UART_Send(id); UART_Send(cmd); UART_Send(d1); UART_Send(d2); UART_Send(0xFF);
    EA = ea;
}
void UART_Req() interrupt 4 {
    if(RI) {
        u8 dat = SBUF; RI=0;
        g_RxBuffer[g_RxCnt++] = dat;
        if(dat == 0xFF || g_RxCnt >= 10) g_MsgReceived = 1;
    }
}

void Parse_Protocol() {
    if(g_RxBuffer[0]==0xAA && g_RxBuffer[5]==0xFF) {
        u8 id = g_RxBuffer[1]; u8 cmd = g_RxBuffer[2]; u8 d1 = g_RxBuffer[3]; u8 d2 = g_RxBuffer[4];
        #if IS_MASTER
            if(cmd == CMD_REPORT) {
                if(id == SLAVE_1_ID) { S1_Data.temp=d1; S1_Data.plant_id=d2; S1_Data.online_cnt=20; }
                if(id == SLAVE_2_ID) { S2_Data.temp=d1; S2_Data.plant_id=d2; S2_Data.online_cnt=20; }
            }
        #else
            if(id == MASTER_ID) {
                if(d1 == CURRENT_ID || d1 == 0xFF) {
                    if(cmd==0x00) g_SysAlarmState=ALARM_NONE;
                    else if(cmd==0xB0) g_SysAlarmState=ALARM_B;
                    else if(cmd==0xC0) g_SysAlarmState=ALARM_C;
                    else if(cmd==0xD0) g_SysAlarmState=ALARM_D;
                }
            }
        #endif
    }
    g_RxCnt = 0; g_MsgReceived = 0;
}

void main() {
    u32 t_read=0, t_led=0, t_upload=0, t_sync=0;
    u8 cmd;

    #if !IS_MASTER
        if(CURRENT_ID == SLAVE_1_ID) g_CurrentPlantIdx = 0;
        else g_CurrentPlantIdx = 5;
    #endif

    Timer0_Init();
    UART_Init();
    OLED_Init();
    OLED_Clear();
    ET2 = 1; 

    while(1) {
        // --- 1. 传感器处理与显示 (500ms) ---
        if (g_SysTick - t_read > 500) {
            t_read = g_SysTick;
            g_Temp = Get_Temp();
            Get_Time();
            
            #if IS_MASTER
                // 主机逻辑
                {
                    u8 s1_err=0, s2_err=0;
                    if(S1_Data.online_cnt) { 
                        if(S1_Data.temp < PlantDB[S1_Data.plant_id].min_temp || S1_Data.temp > PlantDB[S1_Data.plant_id].max_temp) s1_err=1; 
                        S1_Data.online_cnt--; 
                    }
                    if(S2_Data.online_cnt) { 
                        if(S2_Data.temp < PlantDB[S2_Data.plant_id].min_temp || S2_Data.temp > PlantDB[S2_Data.plant_id].max_temp) s2_err=1; 
                        S2_Data.online_cnt--; 
                    }
                    
                    if (!g_ManualMute) {
                        if(s1_err && s2_err) g_SysAlarmState=ALARM_D;
                        else if(s1_err) g_SysAlarmState=ALARM_B;
                        else if(s2_err) g_SysAlarmState=ALARM_C;
                        else g_SysAlarmState=ALARM_NONE;
                    }
                    if (!s1_err && !s2_err) g_ManualMute = 0;
                }
                
                // 主机显示
                if (g_DisplayMode == 0) {
                    // 标题: 温室哨兵
                    OLED_ShowCN(0,0,0); OLED_ShowCN(16,0,1); OLED_ShowCN(32,0,2); OLED_ShowCN(48,0,3);
                    // 第一行: 1号: XX度 / 离线
                    OLED_ShowChar(0,2,'1'); OLED_ShowCN(8,2,7); OLED_ShowChar(24,2,':');
                    if(S1_Data.online_cnt) { OLED_ShowNum(32,2,S1_Data.temp,2); OLED_ShowCN(48,2,10); } 
                    else { OLED_ShowCN(32,2,11); OLED_ShowCN(48,2,12); } // 离线
                    
                    // 第二行: 2号: XX度 / 离线
                    OLED_ShowChar(64,2,'2'); OLED_ShowCN(72,2,7); OLED_ShowChar(88,2,':');
                    if(S2_Data.online_cnt) { OLED_ShowNum(96,2,S2_Data.temp,2); OLED_ShowCN(112,2,10); } 
                    else { OLED_ShowCN(96,2,11); OLED_ShowCN(112,2,12); } // 离线
                } else {
                    // 详情模式
                    u8 pid = (g_DisplayMode==1) ? S1_Data.plant_id : S2_Data.plant_id;
                    // 显示: 1号: 或 2号:
                    OLED_ShowChar(0,0, g_DisplayMode==1 ? '1' : '2'); OLED_ShowCN(8,0,7); OLED_ShowChar(24,0,':');
                    OLED_ShowPlantName(32, 0, pid);
                    // 显示阈值: 20-30
                    OLED_ShowNum(0,2,PlantDB[pid].min_temp,2); OLED_ShowChar(16,2,'-'); OLED_ShowNum(24,2,PlantDB[pid].max_temp,2);
                }
            #else
                // 从机显示
                // 行0: 机号: 01
                OLED_ShowCN(0,0,6); OLED_ShowCN(16,0,7); OLED_ShowChar(32,0,':'); OLED_ShowNum(40,0,CURRENT_ID,2);
                // 行2: 植物: 玫瑰
                OLED_ShowCN(0,2,8); OLED_ShowCN(16,2,9); OLED_ShowChar(32,2,':'); OLED_ShowPlantName(40,2,g_CurrentPlantIdx);
                // 行4: 温度: 25度
                OLED_ShowCN(0,4,0); OLED_ShowCN(16,4,10); OLED_ShowChar(32,4,':'); OLED_ShowNum(40,4,g_Temp,2); OLED_ShowCN(56,4,10);
            #endif
            
            // 显示时间 (底部)
            OLED_ShowNum(32,6,g_Time[2],2); OLED_ShowChar(48,6,':'); OLED_ShowNum(56,6,g_Time[1],2); OLED_ShowChar(72,6,':'); OLED_ShowNum(80,6,g_Time[0],2);
        }
        
        // --- 2. LED与音乐 (50ms) ---
        if (g_SysTick - t_led > 50) {
            t_led = g_SysTick;
            Update_LEDs();
            Update_Music();
        }
        
        // --- 3. 通信 ---
        #if IS_MASTER
            if (g_SysTick - t_sync > 500) {
                t_sync = g_SysTick;
                cmd = 0x00;
                if(g_SysAlarmState==ALARM_B) cmd=0xB0;
                else if(g_SysAlarmState==ALARM_C) cmd=0xC0;
                else if(g_SysAlarmState==ALARM_D) cmd=0xD0;
                Send_Packet(MASTER_ID, cmd, 0xFF, 0xFF); 
            }
        #else
            if (g_SysTick - t_upload > 1000) {
                if (g_SysTick % 1000 > (CURRENT_ID * 200)) {
                    t_upload = g_SysTick;
                    Send_Packet(CURRENT_ID, CMD_REPORT, g_Temp, g_CurrentPlantIdx);
                }
            }
        #endif
        
        // --- 4. 协议解析 & 按键 ---
        if (g_MsgReceived) Parse_Protocol();
        
        if (Key_Common_Press) {
            Key_Common_Press = 0;
            #if IS_MASTER
                g_ManualMute = 1;       
                g_SysAlarmState = ALARM_NONE; 
                Send_Packet(MASTER_ID, 0x00, 0xFF, 0xFF); 
            #else
                g_CurrentPlantIdx++;
                if(g_CurrentPlantIdx > 9) g_CurrentPlantIdx=0;
            #endif
        }
        
        #if IS_MASTER
        if (Key_View_Press) {
            Key_View_Press = 0;
            g_DisplayMode++; if(g_DisplayMode > 2) g_DisplayMode = 0;
            OLED_Clear();
        }
        #endif
    }
}